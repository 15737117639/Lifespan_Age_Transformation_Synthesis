### Copyright (C) 2017 NVIDIA Corporation. All rights reserved.
### Licensed under the CC BY-NC-SA 4.0 license (https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode).
from .base_options import BaseOptions

class TrainOptions(BaseOptions):
    def initialize(self):
        BaseOptions.initialize(self)
        # for displays
        self.parser.add_argument('--display_freq', type=int, default=20, help='frequency of showing training results on screen')
        self.parser.add_argument('--print_freq', type=int, default=20, help='frequency of showing training results on console')
        self.parser.add_argument('--save_latest_freq', type=int, default=2500, help='frequency of saving the latest results')
        self.parser.add_argument('--save_display_freq', type=int, default=2500, help='save the current display of results every save_display_freq_iterations')
        self.parser.add_argument('--save_epoch_freq', type=int, default=1, help='frequency of saving checkpoints at the end of epochs')
        self.parser.add_argument('--no_html', action='store_true', help='do not save intermediate training results to [opt.checkpoints_dir]/[opt.name]/web/')
        self.parser.add_argument('--debug', action='store_true', help='only do one epoch and displays at each iteration')

        # for training
        self.parser.add_argument('--continue_train', action='store_true', help='continue training: load the latest model')
        self.parser.add_argument('--load_pretrain', type=str, default='', help='load the pretrained model from the specified location')
        self.parser.add_argument('--load_pretrained_flow', type=str, default='', help='load a pretrained flow model from the specified location for dual training')
        self.parser.add_argument('--load_pretrained_seg', type=str, default='', help='load a pretrained segmentation model from the specified location for dual training')
        self.parser.add_argument('--add_epoches', action='store_true', help='when true and continue training the starting epoch is added to the total number of epochs')
        self.parser.add_argument('--niter_fix_flow', type=int, default=0, help='number of epochs that we only train the texture model. 0 keeps the flow model fixed throughout training')
        self.parser.add_argument('--niter_fix_seg', type=int, default=0, help='number of epochs that we only train the texture model. 0 keeps the segmentation model fixed throughout training')
        self.parser.add_argument('--which_epoch', type=str, default='latest', help='which epoch to load? set to latest to use latest cached model')
        self.parser.add_argument('--phase', type=str, default='train', help='train, val, test, etc')
        self.parser.add_argument('--niter', type=int, default=10, help='# of iter at starting learning rate')
        self.parser.add_argument('--niter_decay', type=int, default=10, help='# of iter to linearly decay learning rate to zero')
        self.parser.add_argument('--decay_method',type=str, default='linear', choices=['linear','step'], help='type of learning rate decay, choices are linear or step')
        self.parser.add_argument('--decay_epochs', type=str, help='epochs to perform step lr decay')
        self.parser.add_argument('--decay_gamma', type=float, default=0.1, help='decay the learning rate by this value')
        self.parser.add_argument('--alg',type=str, default='adam', choices=['adam','rmsprop', 'sgd'], help='type of optimization algorithm, choices are ADAM, RMSProp and SGD')
        self.parser.add_argument('--beta1', type=float, default=0.9, help='momentum term of adam')
        self.parser.add_argument('--beta2', type=float, default=0.999, help='momentum term of adam')
        self.parser.add_argument('--lr', type=float, default=0.0002, help='initial learning rate for adam')
        self.parser.add_argument('--optimizer_wd', type=float, default=0.0, help='optimizer weight decay')
        self.parser.add_argument('--decay_adain_affine_layers', action='store_true', help='when true adain affine layer learning rate is decayed by 0.01')

        # for discriminators
        self.parser.add_argument('--netD', type=str, default='multiscale', help='selects model to use for texture netD')
        self.parser.add_argument('--two_discriminators', action='store_true', help='Whether or not to use separate discriminators, one for texture and one for segmentation maps')
        self.parser.add_argument('--num_D_flow', type=int, default=3, help='number of discriminators to use in netD_flow')
        self.parser.add_argument('--num_D_tex', type=int, default=1, help='number of discriminators to use in netD_tex')
        self.parser.add_argument('--num_D_seg', type=int, default=3, help='number of discriminators to use in netD_seg')
        self.parser.add_argument('--n_layers_D', type=int, default=3, help='only used if which_model_netD==n_layers')
        self.parser.add_argument('--ndf', type=int, default=64, help='# of discrim filters in first conv layer')
        self.parser.add_argument('--use_norm_D_tex', action='store_true', help='Whether or not to use normalization in discriminators with adain generator')
        self.parser.add_argument('--lambda_feat', type=float, default=0.0, help='weight for feature matching loss')
        self.parser.add_argument('--lambda_class_tex', type=float, default=1.0, help='weight for texture classification loss')
        self.parser.add_argument('--lambda_class_flow', type=float, default=1.0, help='weight for flow classification loss')
        self.parser.add_argument('--lambda_cyc_tex', type=float, default=10.0, help='weight for texture cycle loss')
        self.parser.add_argument('--lambda_cyc_flow', type=float, default=10.0, help='weight for flow cycle loss')
        self.parser.add_argument('--lambda_minflow', type=float, default=0.0, help='weight for minimal flow')
        self.parser.add_argument('--lambda_flowTV', type=float, default=0.0001, help='weight for flow Total Variation')
        self.parser.add_argument('--lambda_landmarks', type=float, default=1, help='weight for landmark distribution loss')
        self.parser.add_argument('--lambda_id_tex', type=float, default=10.0, help='weight for flow id loss')
        self.parser.add_argument('--lambda_id_flow', type=float, default=10.0, help='weight for texture id loss')
        self.parser.add_argument('--lambda_gan_tex', type=float, default=1.0, help='weight for flow adversarial loss')
        self.parser.add_argument('--lambda_gan_flow', type=float, default=1.0, help='weight for texture adversarial loss')
        self.parser.add_argument('--lambda_content', type=float, default=1.0, help='weight for content (id) encoding consistency loss')
        self.parser.add_argument('--lambda_age', type=float, default=1.0, help='weight for age encoding consistency loss')
        self.parser.add_argument('--lambda_embedding', type=float, default=1.0, help='weight for age encoding embedding loss')
        self.parser.add_argument('--orig_age_features_rec_penalty', action='store_true', help='if specified, use use age embedding loss on original images too')
        self.parser.add_argument('--use_background_loss', action='store_true', help='if specified, use L1 loss on the output images background')
        self.parser.add_argument('--use_orig_within_domain', action='store_true', help='if specified, use_original image for within domain pass of adain generator in flow and texture mode')
        self.parser.add_argument('--flow_aux_loss_type', type=str, default='cross_entropy', choices=['cross_entropy', 'multi_margin', 'multi_label_margin', 'multi_label_soft_margin'], help='Aux loss function for flow network. can be: cross_entropy, multi_margin, multi_label_margin, multi_label_soft_margin')
        self.parser.add_argument('--tex_aux_loss_type', type=str, default='cross_entropy', choices=['cross_entropy', 'multi_margin', 'multi_label_margin', 'multi_label_soft_margin'], help='Aux loss function for texture network. can be: cross_entropy, multi_margin, multi_label_margin, multi_label_soft_margin')
        self.parser.add_argument('--num_init_downsample_flow', type=int, default=0, help='number of times to downsample the image before passing it to the flow discriminator')
        self.parser.add_argument('--num_init_downsample_tex', type=int, default=0, help='number of times to downsample the image before passing it to the texture discriminator')
        self.parser.add_argument('--forward_pass_id_loss', action='store_true', help='if specified, id loss is calculated like in the cycle gan code')
        self.parser.add_argument('--use_parsings_in_disc', action='store_true', help='if specified, attach segmentation maps to the texture discriminator inputs')
        self.parser.add_argument('--classify_fakes', action='store_true', help='if specified, classify the fake discriminator examples too')
        self.parser.add_argument('--no_class_loss_flow', action='store_true', help='if specified, do *not* use class loss in flow net')
        self.parser.add_argument('--mse_class_loss_flow', action='store_true', help='if specified, use MSE class loss in flow net')
        self.parser.add_argument('--no_class_loss_tex', action='store_true', help='if specified, do *not* use class loss in texture net')
        self.parser.add_argument('--selective_class_loss_flow', action='store_true', help='if specified, use selective class loss in flow net')
        self.parser.add_argument('--selective_class_loss_tex', action='store_true', help='if specified, use selective class loss in texture net')
        self.parser.add_argument('--selective_class_loss_seg', action='store_true', help='if specified, use selective class loss in segmentation net')
        self.parser.add_argument('--selective_class_type_flow',type=str, default='hinge', choices=['hinge','ls','non_sat'], help='type of selective class loss for flow net, choices are Non saturating loss, HingeGAN or LSGAN')
        self.parser.add_argument('--selective_class_type_tex', type=str, default='hinge', choices=['hinge','ls','non_sat'], help='type of selective class loss for texture net, choices are Non saturating loss, HingeGAN or LSGAN')
        self.parser.add_argument('--selective_class_type_seg', type=str, default='hinge', choices=['hinge','ls','non_sat'], help='type of selective class loss for segmentation net, choices are Non saturating loss, HingeGAN or LSGAN')
        self.parser.add_argument('--add_disc_cond_flow_class', action='store_true', help='if specified, discriminator conditions are added to the output to help the flow class discriminator')
        self.parser.add_argument('--add_disc_cond_tex_class', action='store_true', help='if specified, discriminator conditions are added to the output to help the texture class discriminator')
        self.parser.add_argument('--getFinalFeat_flow', action='store_true', help='if specified, use feature matching loss on the flow discriminator output')
        self.parser.add_argument('--getFinalFeat_tex', action='store_true', help='if specified, use feature matching loss on the texture discriminator output')
        self.parser.add_argument('--no_cycle_loss', action='store_true', help='if specified, do *not* use cycle loss')
        self.parser.add_argument('--no_id_loss', action='store_true', help='if specified, do *not* use identity loss')
        self.parser.add_argument('--no_ganIntermFeat', action='store_true', help='if specified, do *not* use discriminator feature matching loss')
        self.parser.add_argument('--no_vgg_loss', action='store_true', help='if specified, do *not* use VGG feature matching loss')
        self.parser.add_argument('--no_lsgan', action='store_true', help='do *not* use least square GAN, if false, use vanilla GAN')
        self.parser.add_argument('--pool_size', type=int, default=50, help='the size of image buffer that stores previously generated images')

        self.isTrain = True
